/* -*- c -*- */

kernel
Array2D<ulong>
sparse_census(Array2D<uchar> image) 
    @ [image.rows, image.cols]
{
    Array2D<ulong> census[image.rows, image.cols];

    ulong bits = 0;
    uchar ctr = image[$y, $x];
    
    for (int by = 0; by < 8; ++by) {
        int yoff = by + by - 7;
        int ii   = clamp($y + yoff, 0, image.rows);

        for (int bx = 0; bx < 8; ++bx) {
            int xoff = bx + bx - 7;
            int jj   = clamp($x + xoff, 0, image.cols);

            uchar pval = image[ii, jj];
            
            if (pval < ctr) {
                int bit = 8*by + bx;
                bits |= (1 << bit);
            }
        }
    }

    census[$y, $x] = bits;

    return census;
}

ushort
popcount(ulong x) 
{
    const ulong m1 = 0x5555555555555555; //binary: 0101...
    const ulong m2 = 0x3333333333333333; //binary: 00110011..
    const ulong m4 = 0x0f0f0f0f0f0f0f0f; //binary:  4 zeros,  4 ones ...
    const ulong h1 = 0x0101010101010101; //the sum of 256 to the power of 0,1,2,3...
    x -= (x >> 1) & m1;             //put count of each 2 bits into those 2 bits
    x = (x & m2) + ((x >> 2) & m2); //put count of each 4 bits into those 4 bits 
    x = (x + (x >> 4)) & m4;        //put count of each 8 bits into those 8 bits 
    return (x * h1) >> 56;  //returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ... 
}

int
census_window(Array2D<ulong> aa, Array2D<ulong> bb, int yy0, int xx0, int kk)
{
    const int WINDOW_SIZE = 3;
    const int rad = WINDOW_SIZE / 2;

    int cost = 0;

    for (int dy = -rad; dy <= rad; ++dy) {
        for (int dx = -rad; dx <= rad; ++dx) {
            int yy = clamp(yy0 + dy, 0, aa.rows);
            int ax = clamp(xx0 + dx, 0, aa.cols);
            int bx = clamp(ax + kk, 0, aa.cols);
            
            ulong aa_val = aa[yy, ax];
            ulong bb_val = bb[yy, bx];
            cost += popcount(aa_val ^ bb_val);
        }
    }

    return cost;
}

kernel
void
pspace_h(Array3D<uchar> pspace, Array2D<ulong> aa, Array2D<ulong> bb, int direction)
    @ [aa.rows]
{
    int max_disp = aa.cols / 5;

    int low_score;
    int best_disp;
    int prev_disp;
    int jj, kk;

    // traverse left
    prev_disp = -100;

    for (jj = 0; jj < aa.cols; ++kk) {
        best_disp = 0;
        low_score = 99999;

        for (kk = 0; kk < max_disp; ++kk) {
            int score = census_window(aa, bb, $x, jj, kk);
            
            best_disp = (score < low_score) ? kk : best_disp;
            low_score = (score < low_score) ? score : low_score;
        }

        pspace[$x, jj, kk] = best_disp;
        prev_disp = best_disp;
    }

    // traverse right
}

kernel
void
pspace_v(Array3D<uchar> pspace, Array2D<ulong> aa, Array2D<ulong> bb, int direction)
    @ [aa.cols]
{
    // traverse down
    // traverse up
}

kernel
void
pspace_d(Array3D<uchar> pspace, Array2D<ulong> aa, Array2D<ulong> bb, int direction)
    @ [aa.rows + aa.cols]
{
    if ($x < aa.rows) {
        // row $x
    }
    else {
        // col $x - aa.rows
    }

    // top left to bottom right
    // handle diagonal starting at row or column N

    // bottom right to top left
    // row or column (N - $x)

    // bottom left to top right
    // row or column N
    
    // top right to bottom left
    // row or column (N - $x)
}

kernel
Array2D<uchar>
disparity(Array3D<uchar> pspace)
    @ [pspace.rows, pspace.cols]
{
    const int PATHS = 1;
    Array2D<uchar> disp[pspace.rows, pspace.cols];

    int sum = 0;
    
    for (int kk = 0; kk < PATHS; kk++) {
        sum += pspace[kk, $y, $x];
    }

    disp[$y, $x] = sum / PATHS;

    return disp;
}
