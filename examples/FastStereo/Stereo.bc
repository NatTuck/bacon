/* -*- c -*- */

kernel
Array2D<ulong>
sparse_census(Array2D<uchar> image) 
    @range [image.rows, image.cols]
    @group [8, 8]
    global Array2D<ulong> census[image.rows, image.cols];
    local  Array2D<char>  cache [24, 24];
{
    int ii, jj;

    // Each work item loads a 3x3 section of cache.
    int base_cache_row = 3 * $local_row;
    int base_cache_col = 3 * $local_col;
    int base_group_row = $row - $local_row - 7;
    int base_group_col = $col - $local_col - 7;
    int base_image_row = base_group_row + base_cache_row;
    int base_image_col = base_group_col + base_cache_col;

    for (ii = 0; ii < 3; ++ii) {
        int image_row = clamp(base_image_row + ii, 0, (int) image.rows);

        for (jj = 0; jj < 3; ++jj) {
            int image_col = clamp(base_image_col + jj, 0, (int) image.cols);

            cache[base_cache_row + ii, base_cache_col + jj] = 
                image[image_row, image_col];
        }
    }

    int ctr_row = $row - base_group_row;
    int ctr_col = $col - base_group_col;

    ulong bits = 0;
    uchar ctr = cache[ctr_row, ctr_col];
    
    for (int by = 0; by < 8; ++by) {
        int yoff = by + by - 7;
            ii   = ctr_row + yoff;

        for (int bx = 0; bx < 8; ++bx) {
            int xoff = bx + bx - 7;
                jj   = ctr_col + xoff;

            uchar pval = cache[ii, jj];
            
            if (pval < ctr) {
                int bit = 8*by + bx;
                bits |= (1 << bit);
            }
        }
    }

    census[$y, $x] = bits;

    return census;
}

ushort
popcount(ulong x) 
{
    const ulong m1 = 0x5555555555555555; //binary: 0101...
    const ulong m2 = 0x3333333333333333; //binary: 00110011..
    const ulong m4 = 0x0f0f0f0f0f0f0f0f; //binary:  4 zeros,  4 ones ...
    const ulong h1 = 0x0101010101010101; //the sum of 256 to the power of 0,1,2,3...
    x -= (x >> 1) & m1;             //put count of each 2 bits into those 2 bits
    x = (x & m2) + ((x >> 2) & m2); //put count of each 4 bits into those 4 bits 
    x = (x + (x >> 4)) & m4;        //put count of each 8 bits into those 8 bits 
    return (x * h1) >> 56;  //returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ... 
}

int
score_offset(Array2D<ulong> aa, Array2D<ulong> bb, int ii, int jj, int kk)
{
    const int WINDOW_SIZE = 3;
    const int rad = WINDOW_SIZE / 2;

    int cost = 0;

    for (int dy = -rad; dy <= rad; ++dy) {
        for (int dx = -rad; dx <= rad; ++dx) {
            int yy = clamp(ii + dy, 0, (int) aa.rows);
            int bx = clamp(jj + dx, 0, (int) aa.cols);
            int ax = clamp(bx + kk, 0, (int) aa.cols);

            ulong aa_val = aa[yy, ax];
            ulong bb_val = bb[yy, bx];
            cost += popcount(aa_val ^ bb_val);
        }
    }

    return cost;
}

int
subpixel(int c_disp, int p_sc, int c_sc, int n_sc)
{
    float n = n_sc - p_sc;
    float d = 2 * (2*c_sc - p_sc - n_sc);

    float d1 = c_disp;
    
    if (d > 0.0001f) {
        float tweak = n / d;
        d1 += tweak;
    }

    return clamp((int) round(d1), 0, 255);
}

int
sgm_penalty(int aa, int bb)
{
    const int P1 = 5;
    const int P2 = 80;
    const int C1 = 1;
    const int C2 = 2;

    int dd  = abs(aa - bb);
    int pen = 0;

    if (dd > C1) pen += P1;
    if (dd > C2) pen += P2;

    return pen;
}

void
pspace_traverse(Array3D<uchar> pspace, int slice, Array2D<ulong> aa, Array2D<ulong> bb, 
    int disp_dir, int ii0, int ii1, int di, int jj0, int jj1, int dj)
{
    int max_disp = aa.cols / 5;
    int min_disp = 0;

    int prev_score, curr_score, next_score;
    int best_score, best_disp;

    int prev_disp = -100;

    for (int ii = ii0; ii != ii1; ii += di) {
        for (int jj = jj0; jj != jj1; jj += dj) {
            prev_score = score_offset(aa, bb, ii, jj, min_disp * disp_dir);
            curr_score = prev_score;
            next_score = prev_score;

            best_score = 999999;
            best_disp  = 255;

            for (int kk = min_disp; kk < max_disp; ++kk) {
                prev_score = curr_score;
                curr_score = next_score;

                next_score = score_offset(aa, bb, ii, jj, (kk + 1) * disp_dir)
                    + sgm_penalty(kk, prev_disp);

                if (curr_score < best_score) {
                    best_disp  = subpixel(kk, prev_score, curr_score, next_score);
                    best_score = curr_score;
                }
            }

            pspace[slice, ii, jj] = best_disp;
            prev_disp = best_disp;
        }
    }
}

kernel
void
pspace_h(Array3D<uchar> pspace, Array2D<ulong> aa, Array2D<ulong> bb, int direction)
    @range [aa.rows]
{
    // traverse right
    pspace_traverse(pspace, 0, aa, bb, direction, $x, $x+1, +1, 0, aa.cols, +1);
    // traverse left
    pspace_traverse(pspace, 1, aa, bb, direction, $x, $x+1, +1, aa.cols-1, -1, -1);
}

kernel
void
pspace_v(Array3D<uchar> pspace, Array2D<ulong> aa, Array2D<ulong> bb, int direction)
    @range [aa.cols]
{
    // traverse down
    pspace_traverse(pspace, 2, aa, bb, direction, 0, aa.rows, +1, $x, $x+1, +1);
    // traverse up
    pspace_traverse(pspace, 3, aa, bb, direction, aa.rows-1, -1, -1, $x, $x+1, +1);
}

#if 0
kernel
void
pspace_d(Array3D<uchar> pspace, Array2D<ulong> aa, Array2D<ulong> bb, int direction)
    @range [aa.rows + aa.cols]
{
    if ($x < aa.rows) {
        // row $x
    }
    else {
        // col $x - aa.rows
    }

    // top left to bottom right
    // handle diagonal starting at row or column N

    // bottom right to top left
    // row or column (N - $x)

    // bottom left to top right
    // row or column N
    
    // top right to bottom left
    // row or column (N - $x)
}
#endif

kernel
Array2D<uchar>
half_disparity(Array2D<ulong> cA, Array2D<ulong> cB, Array3D<uchar> pspace, int direction)
    @range [pspace.rows, pspace.cols]
    global Array2D<uchar> disp[pspace.rows, pspace.cols];
{
    int max_disp = pspace.rows / 5;
    int min_disp = 0;

#define PATH_COUNT 4
    int path[PATH_COUNT];

    int best_cost = 999999;
    int best_disp = 0;

    for (int ii = 0; ii < PATH_COUNT; ++ii) {
        path[ii] = pspace[ii, $y, $x];
    }

    for (int kk = min_disp; kk < max_disp; ++kk) {
        int cost = score_offset(cA, cB, $y, $x, kk * direction);

        for (int pp = 0; pp < PATH_COUNT; ++pp) {
            cost += sgm_penalty(kk, path[pp]);
        }

        if (cost < best_cost) {
            best_disp = kk;
            best_cost = cost;
        }
    }

    disp[$y, $x] = best_disp;

    return disp;
}

// Fast median of 9 code from N. Devillard,
// http://ndevilla.free.fr/median/median/index.html

#define PIX_SWAP(a,b) temp = (a); (a) = (b); (b) = temp;
#define PIX_SORT(a,b) if ((a)>(b)) { PIX_SWAP((a),(b)) } \

int
opt_med9(int* p)
{
    int temp;
    PIX_SORT(p[1], p[2])  PIX_SORT(p[4], p[5])  PIX_SORT(p[7], p[8]) 
    PIX_SORT(p[0], p[1])  PIX_SORT(p[3], p[4])  PIX_SORT(p[6], p[7]) 
    PIX_SORT(p[1], p[2])  PIX_SORT(p[4], p[5])  PIX_SORT(p[7], p[8]) 
    PIX_SORT(p[0], p[3])  PIX_SORT(p[5], p[8])  PIX_SORT(p[4], p[7]) 
    PIX_SORT(p[3], p[6])  PIX_SORT(p[1], p[4])  PIX_SORT(p[2], p[5]) 
    PIX_SORT(p[4], p[7])  PIX_SORT(p[4], p[2])  PIX_SORT(p[6], p[4]) 
    PIX_SORT(p[4], p[2])  return(p[4]);
}

kernel
Array2D<uchar>
median_filter(Array2D<uchar> im)
    @range [im.rows, im.cols]
    global Array2D<uchar> im2[im.rows, im.cols];
{
    int px[9];
    
    for (int ii = 0; ii < 3; ++ii) {
        int iii = clamp($y + ii - 1, 0, im.rows);

        for (int jj = 0; jj < 3; ++jj) {
            int jjj = clamp($x + jj - 1, 0, im.cols);
            int nn = 3 * ii + jj;
            
            px[nn] = im[iii, jjj];
        }
    }
    
    im2[$y, $x] = opt_med9(px);

    return im2;
}


kernel
Array2D<uchar>
consistent_pixels(Array2D<uchar> dispL, Array2D<uchar> dispR)
    @range [dispL.rows, dispL.cols]
    global Array2D<uchar> disp[dispL.rows, dispL.cols];
{
    const int DV = 3;

    int dL = dispL[$y, $x];
    int jR = clamp((int) round((float) $x + dL), 0, dispL.cols);
    int dR = dispR[$y, jR];

    if (abs(dR - dL) <= DV) {
        disp[$y, $x] = (dR + dL) / 2;
    }
    else {
        disp[$y, $x] = 0;
    }

    return disp;
}

