package Bacon::Stdlib;
use warnings FATAL => 'all';
use strict;
use 5.10.0;

# Some parts of the Bacon standard library want to
# be autogenerated, most obviously the various Array
# struct definitions.

use Bacon::Template;
our @ISA = qw(Bacon::Template);

use IO::Handle;

# TODO: Add "double"
our @TYPES  = qw(char short int long uchar ushort uint ulong float double);
our @SCOPES = qw(global local private);

sub write_structs {
    my ($class, $outf) = @_;
    my $self = bless {}, $class;

    my $defs = "";

    for my $scope (@SCOPES) {
        for my $type (@TYPES) {
            $defs .= $self->fill_section(
                array_structs => 0,
                scope => $scope,
                type  => $type,
            );
        }
    }

    my $hdr = $self->fill_section(
        array_top => 0,
        structs => $defs,
    );

    open my $fh, ">", $outf;
    $fh->print($hdr);
    close($fh);
}

1;

__DATA__

__[ array_top ]__

#ifndef BACON_ARRAY_CL
#define BACON_ARRAY_CL

#pragma OPENCL EXTENSION cl_khr_fp64 : enable

/* == Bacon/Array.cl
# * Structure definitions for Bacon's array data types.
# */

<% $structs %>

#endif

__[ array_structs ]__

struct _Bacon__Array__<% $scope %>__<% $type %> {
    <% $scope %> <% $type %>* data;
    uint size;
};

typedef struct _Bacon__Array__<% $scope %>__<% $type %> _Bacon__Array__<% $scope %>__<% $type %>;

struct _Bacon__Array2D__<% $scope %>__<% $type %> {
    <% $scope %> <% $type %>* data;
    uint rows;
    uint cols;
};

typedef struct _Bacon__Array2D__<% $scope %>__<% $type %> _Bacon__Array2D__<% $scope %>__<% $type %>;
typedef struct _Bacon__Array2D__<% $scope %>__<% $type %> _Bacon__Array2Z__<% $scope %>__<% $type %>;

struct _Bacon__Array3D__<% $scope %>__<% $type %> {
    <% $scope %> <% $type %>* data;
    uint deep;
    uint rows;
    uint cols;
};

typedef struct _Bacon__Array3D__<% $scope %>__<% $type %> _Bacon__Array3D__<% $scope %>__<% $type %>;
typedef struct _Bacon__Array3D__<% $scope %>__<% $type %> _Bacon__Array3Z__<% $scope %>__<% $type %>;
