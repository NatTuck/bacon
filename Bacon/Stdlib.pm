package Bacon::Stdlib;
use warnings FATAL => 'all';
use strict;
use 5.10.0;

# Some parts of the Bacon standard library want to
# be autogenerated, most obviously the various Array
# struct definitions.

use Bacon::Template;
our @ISA = qw(Bacon::Template);

use IO::Handle;

our @TYPES = qw(char short int long uchar ushort uint ulong float);
# TODO: Add "double"

sub write_structs {
    my ($class, $outf) = @_;
    my $self = bless {}, $class;

    my $defs = "";

    for my $type (@TYPES) {
        $defs .= $self->fill_section(
            array_structs => 0,
            type => $type,
        );
    }

    my $hdr = $self->fill_section(
        array_top => 0,
        structs => $defs,
    );

    open my $fh, ">", $outf;
    $fh->print($hdr);
    close($fh);
}

1;

__DATA__

__[ array_top ]__

#ifndef BACON_ARRAY_CL
#define BACON_ARRAY_CL

/* == Bacon/Array.cl
#* Structure definitions for Bacon's array data types.
#*/

<% $structs %>

#endif

__[ array_structs ]__

struct _Bacon__Array__<% $type %> {
    global <% $type %>* data;
    uint size;
};

typedef struct _Bacon__Array__<% $type %> _Bacon__Array__<% $type %>;

struct _Bacon__Array2D__<% $type %> {
    global <% $type %>* data;
    uint rows;
    uint cols;
};

typedef struct _Bacon__Array2D__<% $type %> _Bacon__Array2D__<% $type %>;
typedef struct _Bacon__Array2D__<% $type %> _Bacon__Array2Z__<% $type %>;

struct _Bacon__Array3D__<% $type %> {
    global <% $type %>* data;
    uint deep;
    uint rows;
    uint cols;
};

typedef struct _Bacon__Array3D__<% $type %> _Bacon__Array3D__<% $type %>;
typedef struct _Bacon__Array3D__<% $type %> _Bacon__Array3Z__<% $type %>;
